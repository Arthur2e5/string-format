// Generated by CoffeeScript 1.6.3
(function() {
  var Expression, KeyError, Literal, ValueError, eval_, format, last, primitives, tokenize,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  last = function(array) {
    return array[array.length - 1];
  };

  KeyError = (function(_super) {
    __extends(KeyError, _super);

    function KeyError(message) {
      this.message = message;
    }

    KeyError.prototype.name = 'KeyError';

    return KeyError;

  })(Error);

  ValueError = (function(_super) {
    __extends(ValueError, _super);

    function ValueError(message) {
      this.message = message;
    }

    ValueError.prototype.name = 'ValueError';

    return ValueError;

  })(Error);

  Literal = (function() {
    function Literal(value) {
      this.value = value;
    }

    return Literal;

  })();

  Expression = (function() {
    function Expression(source) {
      this.source = source;
      this.field_name = '';
      this.transformer = '';
      this.format_spec = '';
    }

    return Expression;

  })();

  tokenize = function(source) {
    var FIELD_NAME, FORMAT_SPEC, TRANSFORMER, chr, idx, next, states, token, tokens, _i, _j, _len, _len1, _ref;
    tokens = [new Literal('')];
    idx = 0;
    next = function() {
      return source[idx + 1];
    };
    while (idx !== source.length) {
      chr = source[idx];
      if (last(tokens) instanceof Literal) {
        if (chr === '{') {
          if (next() === '{') {
            last(tokens).value += '{';
            idx += 1;
          } else {
            tokens.push(new Expression(''));
          }
        } else if (chr === '}') {
          if (next() === '}') {
            last(tokens).value += '}';
            idx += 1;
          } else {
            throw new ValueError('unmatched, unescaped "}" in format string');
          }
        } else {
          last(tokens).value += chr;
        }
      } else {
        if (chr === '}') {
          tokens.push(new Literal(''));
        } else {
          last(tokens).source += chr;
        }
      }
      idx += 1;
    }
    if (last(tokens) instanceof Expression) {
      throw new ValueError('unmatched, unescaped "{" in format string');
    }
    FIELD_NAME = {};
    TRANSFORMER = {};
    FORMAT_SPEC = {};
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
      token = tokens[_i];
      if (!(token instanceof Expression)) {
        continue;
      }
      states = [FIELD_NAME];
      _ref = token.source;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        chr = _ref[_j];
        switch (last(states)) {
          case FIELD_NAME:
            if (chr === '!') {
              states.push(TRANSFORMER);
              continue;
            }
            if (chr === ':') {
              states.push(FORMAT_SPEC);
              continue;
            }
            token.field_name += chr;
            break;
          case TRANSFORMER:
            if (chr === ':') {
              states.push(FORMAT_SPEC);
              continue;
            }
            token.transformer += chr;
            break;
          case FORMAT_SPEC:
            token.format_spec += chr;
        }
      }
      if (__indexOf.call(states, TRANSFORMER) >= 0 && token.transformer === '') {
        throw new ValueError('invalid transformer name');
      }
    }
    return tokens;
  };

  primitives = {
    boolean: Boolean,
    number: Number,
    string: String
  };

  eval_ = function(expr, ctx) {
    var key, type, _i, _len, _ref;
    _ref = expr.field_name.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      type = typeof ctx;
      if (!(key in (type in primitives ? new primitives[type] : ctx))) {
        throw new KeyError('"{}"'.format(key.replace(/"/g, '\\"')));
      } else if (Object.prototype.toString.call(ctx[key]) === '[object Function]') {
        ctx = ctx[key]();
      } else {
        ctx = ctx[key];
      }
    }
    if (expr.transformer === '') {
      return ctx;
    } else if (Object.prototype.hasOwnProperty.call(String.prototype.format.transformers, expr.transformer)) {
      return String.prototype.format.transformers[expr.transformer].call(ctx);
    } else {
      throw new ValueError('unknown transformer "{}"'.format(expr.transformer.replace(/"/g, '\\"')));
    }
  };

  format = function() {
    var args, idx, modes, template, token, values;
    template = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    idx = 0;
    modes = [];
    values = (function() {
      var _i, _len, _ref, _results;
      _ref = tokenize(template);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        switch (token.constructor) {
          case Literal:
            _results.push(token.value);
            break;
          case Expression:
            modes.push(token.field_name ? 'explicit' : 'implicit');
            if (last(modes) !== modes[0]) {
              throw new ValueError('cannot switch from {} to {} numbering'.format(modes[0], last(modes)));
            }
            if (/^\D/.test(token.field_name)) {
              token.field_name = "0." + token.field_name;
            }
            token.field_name || (token.field_name = "" + (idx++));
            _results.push(eval_(token, args));
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    })();
    return values.join('');
  };

  String.prototype.format = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return format.apply(null, [this].concat(__slice.call(args)));
  };

  String.prototype.format.transformers = format.transformers = {};

  String.prototype.format.version = format.version = '0.2.1';

  if (typeof module !== "undefined" && module !== null) {
    module.exports = format;
  }

}).call(this);
